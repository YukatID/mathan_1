import numpy as np
import random
import math
import itertools
from sympy import factorial
Тема 1. Знакомство с математическим анализом*
1. Как относятся друг к другу множество и последовательность? (в ответе использовать слова типа: часть, целое, общее, частное, родитель, дочерний субъект и т.д.)

Ответ: Поскольку последовательности являются результатом выбора элементов заданных множеств, я бы сказал что последовательность относится к множеству как дочерний субъект к родителю
Тема 2. Множество*
3. Даны три множества a, b и с. Необходимо выполнить все изученные виды бинарных операций над всеми комбинациями множеств.

3.1. Выполнить задание 1 на языке Python

random.seed(42)
a = set([random.randint(0, 99) for _ in range(random.randint(1, 10))])
b = set([random.randint(0, 99) for _ in range(random.randint(1, 10))])
c = set([random.randint(0, 99) for _ in range(random.randint(1, 10))])
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
a: {3, 94}
b: {13, 17, 28, 94, 31}
c: {64, 3, 4, 75, 11, 54, 27, 29}
sets = {
    'a': a,
    'b': b,
    'c': c
}
for combination in itertools.combinations(sets.keys(), 2):
    x, y = combination[0], combination[1]
    print(f'Множества: {x}, {y}')
    print(f'x: {sets[x]},\ny: {sets[y]}')
    print(f'Объединение {x} | {y}: {sets[x] | sets[y]}')
    print(f'Пересечение {x} & {y}: {sets[x] & sets[y]}')
    print(f'Разность {x} - {y}: {sets[x] - sets[y]}')
    print(f'Симметрическая разность {x} ^ {y}: {sets[x] ^ sets[y]}')
    cartesian = []
    for item in itertools.product(sets[x], sets[y]):
        cartesian.append(item)
    print(f'Декартово произведение {x} * {y}: {set(cartesian)}')
    print()
Множества: a, b
x: {3, 94},
y: {13, 17, 28, 94, 31}
Объединение a | b: {17, 3, 28, 13, 94, 31}
Пересечение a & b: {94}
Разность a - b: {3}
Симметрическая разность a ^ b: {17, 3, 28, 13, 31}
Декартово произведение a * b: {(3, 13), (3, 94), (3, 31), (94, 17), (94, 28), (3, 28), (94, 31), (94, 94), (3, 17), (94, 13)}

Множества: a, c
x: {3, 94},
y: {64, 3, 4, 75, 11, 54, 27, 29}
Объединение a | c: {64, 3, 4, 75, 11, 54, 27, 29, 94}
Пересечение a & c: {3}
Разность a - c: {94}
Симметрическая разность a ^ c: {64, 4, 75, 11, 54, 27, 29, 94}
Декартово произведение a * c: {(94, 27), (3, 3), (3, 54), (94, 64), (3, 64), (94, 3), (3, 75), (3, 11), (94, 54), (94, 75), (94, 11), (94, 29), (3, 29), (94, 4), (3, 4), (3, 27)}

Множества: b, c
x: {13, 17, 28, 94, 31},
y: {64, 3, 4, 75, 11, 54, 27, 29}
Объединение b | c: {64, 3, 4, 75, 11, 13, 17, 54, 27, 28, 29, 94, 31}
Пересечение b & c: set()
Разность b - c: {13, 17, 28, 94, 31}
Симметрическая разность b ^ c: {64, 3, 4, 75, 11, 13, 17, 54, 27, 28, 29, 94, 31}
Декартово произведение b * c: {(31, 75), (28, 4), (28, 29), (17, 29), (13, 4), (94, 29), (31, 54), (17, 3), (13, 54), (94, 64), (28, 75), (13, 3), (17, 64), (17, 11), (94, 54), (94, 11), (17, 54), (13, 29), (28, 27), (28, 64), (13, 64), (13, 11), (31, 11), (31, 29), (94, 3), (31, 4), (28, 3), (94, 4), (31, 3), (17, 27), (17, 4), (94, 27), (28, 11), (17, 75), (28, 54), (13, 27), (94, 75), (31, 27), (31, 64), (13, 75)}
Тема
3.
Последовательность *
4.
Даны
4
последовательности.Необходимо:

исследовать
их
на
монотонность;
исследовать
на
ограниченность;
найти
пятый
по
счету
член.


def monotony(sequence):
    for i in range(1, len(sequence)):
        if sequence[i] > sequence[i - 1]:
            return 'Последовательность монотонно возрастает'
        elif sequence[i] < sequence[i - 1]:
            return 'Последовательность монотонно убывает'
        else:
            return 'Последовательность не изменяетя'


# a: 2 ** n - n
# n = 1, +oo

# последовательность ограничена снизу числом 1

def f1(n):
    return 2 ** n - n


ns = list(range(1, 11, 1))
elements = list(map(f1, ns))

print(monotony(elements))
print(f'Перывые 10 элементов последовательности 2 ^ n - n: \n{elements}')
print(f'Пятый по счету член последовательности 2 ^ n - n: {f1(ns[4])}')
Последовательность
монотонно
возрастает
Перывые
10
элементов
последовательности
2 ^ n - n:
[1, 2, 5, 12, 27, 58, 121, 248, 503, 1014]
Пятый
по
счету
член
последовательности
2 ^ n - n: 27


# b: 1 / (n - 1)
# n = 2, +oo

# последовательность ограничена сверху числом 1

def f2(n):
    return 1 / (n - 1)


ns = list(range(2, 12, 1))
elements = list(map(f2, ns))

print(monotony(elements))
print(f'Перывые 10 элементов последовательности 1 / (n - 1): \n{elements}')
print(f'Пятый по счету член последовательности 1 / (n - 1): {f2(ns[4])}')
Последовательность
монотонно
убывает
Перывые
10
элементов
последовательности
1 / (n - 1):
[1.0, 0.5, 0.3333333333333333, 0.25, 0.2, 0.16666666666666666, 0.14285714285714285, 0.125, 0.1111111111111111, 0.1]
Пятый
по
счету
член
последовательности
1 / (n - 1): 0.2


# b: -1 ** n + sqrt(2 * n)
# n = 1, +oo

# последовательность ограничена снизу числом -1

def f3(n):
    return -1 ** n + math.sqrt(2 * n)


ns = list(range(1, 11, 1))
elements = list(map(f3, ns))

print(monotony(elements))
print(f'Перывые 10 элементов последовательности -1 ^ n + sqrt(2 * n): \n{elements}')
print(f'Пятый по счету член последовательности -1 ^ n + sqrt(2 * n): {f3(ns[4])}')
Последовательность
монотонно
возрастает
Перывые
10
элементов
последовательности - 1 ^ n + sqrt(2 * n):
[0.41421356237309515, 1.0, 1.4494897427831779, 1.8284271247461903, 2.1622776601683795, 2.4641016151377544,
 2.7416573867739413, 3.0, 3.2426406871192848, 3.4721359549995796]
Пятый
по
счету
член
последовательности - 1 ^ n + sqrt(2 * n): 2.1622776601683795


# b: (-1) ** (2 * n) + 1 / (n ** 2)
# n = 1, +oo

# последовательность ограничена сверху числом 2

def f4(n):
    return (-1) ** (2 * n) + 1 / (n ** 2)


ns = list(range(1, 11, 1))
elements = list(map(f4, ns))

print(monotony(elements))
print(f'Перывые 10 элементов последовательности (-1) ^ (2 * n) + 1 / (n ^ 2): \n{elements}')
print(f'Пятый по счету член последовательности (-1) ^ (2 * n) + 1 / (n ^ 2): {f4(ns[4])}')
Последовательность
монотонно
убывает
Перывые
10
элементов
последовательности(-1) ^ (2 * n) + 1 / (n ^ 2):
[2.0, 1.25, 1.1111111111111112, 1.0625, 1.04, 1.0277777777777777, 1.0204081632653061, 1.015625, 1.0123456790123457,
 1.01]
Пятый
по
счету
член
последовательности(-1) ^ (2 * n) + 1 / (n ^ 2): 1.04
4.
a1 = 128, a(n + 1) - a(n) = 6, найти
12 - й
член
заданной
неявно
последовательности

a1 = 128
d = 6

# a(n) = a1 + (n - 1) * d

a12 = a1 + (12 - 1) * d

print(f'a12: {a12}')
a12: 194
a1 = 128
d = 6

a12 = a1
for _ in range(11):
    a12 += d

print(f'a12: {a12}')
a12: 194
5.
На
языке
Python
предложить
алгоритм
вычисляющий
численно
предел
с
точностью
e = 10 ^ (-7)

6.
Предложить
оптимизацию
алгоритма, полученного
в
задании
5, ускоряющую
его
сходимость.


# n / (n! ** (1 / n))
# n = 1, +oo

def f(n):
    return n / pow(factorial(n), 1 / n)

% % time
eps = 10 ** -7
i = 1
n = 1
x0 = f(n)
while True:
    i += 1
    n += 1
    x1 = f(n)
    if abs(x0 - x1) <= eps:
        break
    x0 = x1
print(f'n_iter: {i}')
print(f'f(n) = {x0}')
n_iter: 11779
f(n) = 2.71698832372746
CPU
times: user
9
s, sys: 154
ms, total: 9.15
s
Wall
time: 9.18
s
% % time
eps = 10 ** -7
i = 1
n = 1
x0 = f(n)
while True:
    i += 1
    n += random.randint(1, 100)
    x1 = f(n)
    if abs(x0 - x1) <= eps:
        break
    x0 = x1
print(f'n_iter: {i}')
print(f'f(n) = {x0}')
n_iter: 236
f(n) = 2.71702913610648
CPU times: user 132 ms, sys: 2.26 ms, total: 135 ms
Wall time: 133 ms